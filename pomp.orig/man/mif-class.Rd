\name{mif-class}
\docType{class}
\alias{mif-class}
\alias{coef,mif-method}
\alias{coef-mif}
\alias{coef<-,mif-method}
\alias{coef<--mif}
\alias{continue,mif-method}
\alias{continue-mif}
\alias{conv.rec,mif-method}
\alias{conv.rec-mif}
\alias{filter.mean,mif-method}
\alias{filter.mean-mif}
\alias{logLik,mif-method}
\alias{logLik-mif}
\alias{mif,mif-method}
\alias{mif-mif}
\alias{simulate,mif-method}
\alias{simulate-mif}
\alias{pfilter,mif-method}
\alias{pfilter-mif}
\alias{plot,mif-method}
\alias{plot-mif}
\alias{predvarplot,mif-method}
\alias{predvarplot-mif}
\alias{pred.mean,mif-method}
\alias{pred.mean-mif}
\alias{pred.var,mif-method}
\alias{pred.var-mif}
\alias{print,mif-method}
\alias{print-mif}
\alias{show,mif-method}
\alias{show-mif}
\alias{particles,mif-method}
\alias{particles-mif}

\title{Class "mif"}
\description{The MIF algorithm: maximum likelihood via iterated filtering}
\section{Objects from the Class}{
  Objects can be created by calls to the \code{mif} method on an
  \code{pomp} object.
}
\section{Slots}{
  \describe{
    \item{\code{ivps}:}{A character vector containing the names of
      variables appearing in \code{theta} which are to be treated as
      initial-value parameters (IVPs).}
    \item{\code{pars}:}{A character vector containing the names of
      variables appearing in \code{theta} which are to be treated as
      parameters.}
    \item{\code{stvs}:}{A character vector containing the names of
      variables appearing in \code{theta} which are to be treated as
      state variables.}
    \item{\code{loglik}:}{A numeric value containing the value of the
      log-likelihood, as evaluated for the random-parameter model.}
    \item{\code{Nmif}:}{Number of MIF iterations that have been
      completed.}
    \item{\code{alg.pars}:}{A named list containing the specification of
      the algorithm parameters.  This consists of the following elements:
      \item{\code{cooling.factor}:}{the factor defining the exponential
	cooling schedule.}
      \item{\code{Np}:}{number of particles used.}
      \item{\code{CC}:}{the initial parameter SD multiplier.}
      \item{\code{T0}:}{an integer specifying the fixed lag for
	smoothing of IVPs.}
    }
    \item{\code{coef}:}{A named vector containing the parameter estimate.}
    \item{\code{random.walk.sd}:}{A named vector containing the random-walk
      variance to be used for ordinary parameters.  The width of the
      initial distribution of particles will be CC*sigma.}
    \item{\code{pred.mean}:}{Matrix of prediction means.}
    \item{\code{pred.var}:}{Matrix of prediction variances.}
    \item{\code{filter.mean}:}{Matrix of filtering means.}
    \item{\code{conv.rec}:}{The "convergence record": a matrix
      containing a record of the parameter values, log-likelihoods, and
      other pertinent information, with one row for each MIF iteration.}
    \item{\code{data}:}{Inherited from the 'pomp' class.}
    \item{\code{t0}:}{Inherited from the 'pomp' class.}
    \item{\code{particles}:}{Inherited from the 'pomp' class.}
    \item{\code{rprocess}:}{Inherited from the 'pomp' class.}
    \item{\code{dmeasure}:}{Inherited from the 'pomp' class.}
    \item{\code{rmeasure}:}{Inherited from the 'pomp' class.}
    \item{\code{userdata}:}{Inherited from the 'pomp' class.}
  }
}
\section{Extends}{
  Class \code{"pomp"}, directly.  See \code{\link{pomp-class}}.
}
\section{Methods}{
  \describe{
    \item{coef}{Returns the value of the \code{coef} slot.  These
      represent the best-fit parameters, generated by MIF.}
    \item{coef<-}{Assigns values to coefficients.
      \code{coef(object,names=NULL) <- value} has the effect of
      replacing the coefficients with the specified names with the given
      values.  By default, if \code{value} has a names attribute, these
      names are used, otherwise the names attribute of
      \code{coef(object)} is used.}
    \item{continue}{Continues a series of MIF iterations where they have
      been left off.  See the documentation below under \cite{Continuing
	MIF Iterations}.}
    \item{conv.rec}{conv.rec(object, pars = NULL) returns the columns of
      the convergence-record matrix corresponding to the names in
      \code{pars}.  By default, all rows are returned.}
    \item{filter.mean}{filter.mean(object, pars = NULL) returns the rows
      of the filtering-mean matrix corresponding to the names in
      \code{pars}.  By default, all rows are returned.}
    \item{logLik}{Returns the value in the \code{loglik} slot.}
    \item{mif}{Re-runs the MIF iterations.  See the documentation under
      \cite{Re-running MIF Iterations} below.}
    \item{pfilter}{Runs a particle filter.  See the documentation below
      under \cite{Running the Particle Filter}.}
    \item{plot}{Plots a series of diagnostic plots.}
    \item{pred.mean}{pred.mean(object, pars = NULL) returns the rows of
      the prediction-mean matrix corresponding to the names in
      \code{pars}.  By default, all rows are returned.}
    \item{predvarplot}{\code{predvarplot(object, pars = NULL, mean =
	FALSE, ...)} produces a plot of the scaled prediction variances
      for each parameter.  This can be used to diagnose a good value of
      the \code{mif} parameters \code{CC} and \code{T0}.  If used in
      this way, one should run \code{mif} with \code{Nmif=1} first.
      Additional arguments in \code{...} will be passed to the actual
      plotting function.}
    \item{pred.var}{pred.var(object, pars = NULL) returns the rows of
      the prediction-variance matrix corresponding to the names in
      \code{pars}.  By default, all rows are returned.}
    \item{print}{Prints a summary of the "mif" object.}
    \item{show}{Displays the "mif" object.}
    \item{particles}{Creates the matrix of particles by drawing from the
      initial distribution of particles.  See the documentation below
      under \cite{Initial Distribution of the Particles}.}
    \item{simulate}{Simulates a data series.  See the documentation
      below under \cite{Running Simulations}.}
  }
}
\section{Re-running MIF Iterations}{
  To re-run a sequence of MIF iterations, one can use the \code{mif}
  method on a "mif" object.  The call sequence is

  \code{mif(object, ...)}

  Any additional arguments that are valid for the \code{mif} method of
  an "pomp" object (see \code{\link{pomp-class}}) can be given.
  Arguments not specified will take the values they have in the slots of
  \code{object}.
}
\section{Continuing MIF Iterations}{
  One can continue a series of MIF iterations from where one left off.
  The call sequence is

  \code{continue(object, Nmif, ...)}

  This will perform \code{Nmif} additional MIF iterations on the "mif"
  object \code{object}.  A call to \code{mif} to perform \code{Nmif=m}
  iterations followed by a call to \code{continue} to perform
  \code{Nmif=n} iterations will produce precisely the same effect as a
  single call to \code{mif} to perform \code{Nmif=m+n} iterations.

  All additional arguments are passed to \code{mif}.  This feature can
  be used to change any of the parameters.
}
\section{Running the Particle Filter}{
  One can estimate the likelihood of a constant-parameter state-space
  model using a particle filter (AKA sequential Monte Carlo) method.
  The call sequence is

  \code{pfilter(object, Np = NULL, coef = NULL, tol = 1e-17, warn = TRUE, max.fail = 0)}

  The arguments are as follows
  \describe{
    \item{object}{The "mif" object}
    \item{Np}{The number of particles to use.  By default, use the same
      number of particles that were used in the MIF iterations, i.e.,
      \code{object@Np}.}
    \item{coef}{The parameters at which the log-likelihood is desired.
      By default, use the best-fit parameters, i.e., \code{best@theta}.}
    \item{tol}{Particles with log likelihood below \code{tol} are
      considered to be "lost".  A filtering failure occurs when, at some
      time point, all particles are lost.}
    \item{warn}{Should the user be warned about filtering failures?}
    \item{max.fail}{The maximum number of filtering failures allowed.
      If the number of filtering failures exceeds this number,
      execution will terminate with an error.}
  }

  \code{pfilter} returns a list with the following elements
  \describe{
    \item{loglik}{The estimated log-likelihood}
    \item{nfail}{The number of filtering failures encountered}
    \item{eff.sample.size}{A vector containing the effective number of
      particles at each time point.}
    \item{cond.loglik}{A vector containing the conditional
      log-likelihoods at each time point.}
  }
}
\section{Running Simulations}{
  The call sequence for the \code{simulate} method is

  \code{simulate(object,nsim=1,seed=NULL,return.as=c('pomp','obs','states','both'))}
    
  The arguments are as follows
  \describe{
    \item{object}{An object of class "mif"}
    \item{nsim}{The number of simulations to perform}
    \item{seed}{The random seed to use.}
    \item{return.as}{the type of object to return.  If
      \code{return.as=='pomp'}, an "pomp" object will be returned.  It
      will be identical to \code{object}, but its \code{data} slot will
      have  been replaced by the simulated data.  If \code{nsim>1}, then
      a list of "pomp" objects will be returned.  If
      \code{return.as=='obs'}, a rank-3 array with third dimension
      \code{nsim} is returned.  If \code{y} is the array returned, then
      for each \code{k}, \code{y[,,k]} is a simulated data set.  If
      \code{return.as=='states'}, a rank-3 array with the simulated
      trajectories of the \code{nsim} particles is returned.  The
      dimensions of the array is (\code{nv x nsim x nt} where \code{nv} is
      the number of variables defining a particle and \code{nt} is the
      number of times.  If \code{return.as=='both'}, a named list is
      returned.  The "obs" element, as before, contains a matrix of
      simulated observations.
    }
  }
  The model is simulated at the parameters in the \code{coef}
  slot (see above).
}
\section{Initial Distribution of the Particles}{
  The \code{particles} method is used to set up the initial distribution
  of particles.  The call sequence is

  \code{particles(object, Np = NULL, center = NULL, sd = NULL)}

  The arguments are as follows
  \describe{
    \item{object}{the "mif" object}
    \item{Np}{the number of particles, i.e., number of draws.}
    \item{center}{the central value of the distribution of particles}
    \item{sd}{the width of the distribution}
  }
  If any of \code{Np}, \code{center}, or \code{sd} are NULL, they will
  be filled in using the values in the corresponding slots of
  \code{object}.

  \code{particles} returns the particle matrix of \code{Np} columns.
}
\references{}
\author{Aaron A. King (kingaa at umich dot edu)}
\seealso{\code{\link{pomp}}, \code{\link{pomp-class}}}
\keyword{models}
\keyword{ts}
